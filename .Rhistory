df_clean <- df_clean %>%
mutate(
date_diff = as.numeric(as.Date(as.character(SPEC_DATE), format="%Y-%m-%d") -
as.Date(as.character(DATE_ADMIS), format="%Y-%m-%d")),
NOSOCOMIAL1 = case_when(
is.na(date_diff) & WARD_TYPE == 'in' & date_diff <= 2 ~ 'Y',
is.na(date_diff) & WARD_TYPE == 'in' & date_diff > 2 ~ 'N',
WARD_TYPE == 'out' ~ 'O',
WARD_TYPE == 'in' & DATE_ADMIS == '' ~ 'X',
SPEC_TYPE != 'qc' ~ 'U',
TRUE ~ ''
)
)
View(df_clean)
# Compute the difference between the two date columns and convert to numeric
df_clean <- df_clean %>%
mutate(
date_diff = as.numeric(as.Date(as.character(SPEC_DATE), format="%Y-%m-%d") -
as.Date(as.character(DATE_ADMIS), format="%Y-%m-%d")),
NOSOCOMIAL1 = case_when(
is.na(date_diff) & WARD_TYPE == 'in' & date_diff <= 2 ~ 'Y',
is.na(date_diff) & WARD_TYPE == 'in' & date_diff > 2 ~ 'N',
WARD_TYPE == 'out' ~ 'O',
WARD_TYPE == 'in' & DATE_ADMIS == '' ~ 'X',
SPEC_TYPE != 'qc' & NOSOCOMIAL1 == '' ~ 'U',
TRUE ~ ''
)
)
View(df_clean)
df_clean <- df_clean %>%
mutate(
date_diff = as.numeric(as.Date(as.character(SPEC_DATE), format="%Y-%m-%d") -
as.Date(as.character(DATE_ADMIS), format="%Y-%m-%d")),
NOSOCOMIAL1 = case_when(
is.na(date_diff) & WARD_TYPE == 'in' & date_diff <= 2 ~ 'Y',
is.na(date_diff) & WARD_TYPE == 'in' & date_diff > 2 ~ 'N',
WARD_TYPE == 'out' ~ 'O',
WARD_TYPE == 'in' & DATE_ADMIS == '' ~ 'X',
TRUE ~ ''
)
)
View(df_clean)
View(df_clean)
df_clean <- df_clean %>%
mutate(
date_diff = as.numeric(as.Date(as.character(SPEC_DATE), format="%Y-%m-%d") -
as.Date(as.character(DATE_ADMIS), format="%Y-%m-%d")),
NOSOCOMIAL1 = case_when(
is.na(date_diff) & WARD_TYPE == 'in' & date_diff <= 2 ~ 'Y',
is.na(date_diff) & WARD_TYPE == 'in' & date_diff > 2 ~ 'N',
WARD_TYPE == 'out' ~ 'O',
WARD_TYPE == 'in' & DATE_ADMIS == '' ~ 'X',
TRUE ~ ''
)
)
View(df_clean)
df_clean <- df_clean %>%
mutate(
date_diff = as.numeric(as.Date(as.character(SPEC_DATE), format="%Y-%m-%d") -
as.Date(as.character(DATE_ADMIS), format="%Y-%m-%d")),
NOSOCOMIAL1 = case_when(
WARD_TYPE == 'out' ~ 'O',
WARD_TYPE == 'in' & DATE_ADMIS == '' ~ 'X',
WARD_TYPE == 'in' & !is.na(date_diff) & date_diff <= 2 ~ 'Y',
WARD_TYPE == 'in' & !is.na(date_diff) & date_diff > 2 ~ 'N',
TRUE ~ ''  # Default case if no condition matches
)
)
View(df_clean)
df$NOSOCOMIAL1 <- ifelse(df$SPEC_TYPE != 'qc' & df$NOSOCOMIAL == '','U',df$NOSOCOMIAL1)
df_clean$NOSOCOMIAL1 <- ifelse(df_clean$SPEC_TYPE != 'qc' & df_clean$NOSOCOMIAL == '','U',df_clean$NOSOCOMIAL1)
View(df_clean)
gc()
df <- read.csv("site_df/df_2024.csv")
names(df) <- toupper(names(df))
df$INSTITUT <- toupper(df$INSTITUT)
date_formats <- c(
"ymd HMS",  # YYYY-MM-DD HH:MM:SS
"mdy HM",   # MM/DD/YYYY HH:MM
"mdy"       # MM/DD/YYYY
)
# Use parse_date_time to handle multiple formats in a vectorized way
df$DATE_BIRTH <- parse_date_time(df$DATE_BIRTH, orders = date_formats)
df$DATE_DATA <- parse_date_time(df$DATE_DATA, orders = date_formats)
df$DATE_ADMIS <- parse_date_time(df$DATE_ADMIS, orders = date_formats)
df$SPEC_DATE <- parse_date_time(df$SPEC_DATE, orders = date_formats)
#convert date/time to character
df$DATE_BIRTH <- as.character(df$DATE_BIRTH)
df$DATE_DATA <- as.character(df$DATE_DATA)
df$DATE_ADMIS <- as.character(df$DATE_ADMIS)
df$SPEC_DATE <- as.character(df$SPEC_DATE)
#set x_referred value to blank for regular data
df$X_REFERRED <- ''
df[is.na(df)] <- ''
df[df == 'nan'] <- ''
df[df == 'NaN'] <- ''
df[df == 'NaT'] <- ''
df_clean <- df
View(df)
gc()
abx <- c('.', '12.5', 12, '13.1', '<15', '>=30', '>10.5', '>.25', '>0.25')
# Remove periods only from isolated periods or non-numeric-like strings
abx_cleaned <- sapply(abx, function(x) {
if (x == ".") {  # Remove isolated period
return("")
} else if (grepl("^[><]?\\d*\\.?\\d+$", x)) {  # Keep numeric-like strings with or without comparison operators
return(x)
} else {
return(gsub("\\.", "", x))  # Remove periods from non-numeric strings
}
})
# Print the cleaned result
print(abx_cleaned)
abx <- c('.', '12.5', 12, '13.1', '<15', '>=30', '>10.5', '>.25', '>0.25', 'hello', 'abc', 'R','I','S','R')
# Define a regular expression that matches valid formats
valid_format <- grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", abx)
# Keep only the values that match the valid format
abx_cleaned <- abx[valid_format]
# Print the cleaned result
print(abx_cleaned)
abx <- c('.', '12.5', 12, '13.1', '<15', '>=30', '>10.5', '>.25', '>0.25', 'hello', 'abc', 'R','I','S','R')
# Remove all whitespaces
abx_cleaned <- gsub("\\s+", "", abx)
# Define a regular expression that matches valid formats
valid_format <- grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", abx)
# Keep only the values that match the valid format
abx_cleaned <- abx[valid_format]
# Print the cleaned result
print(abx_cleaned)
site_code <- 'BGH'
#load data
df <- read.csv(paste0("site_df/",site_code ,"_raw_df.csv"))
#change column names case to upper
names(df) <- toupper(names(df))
df$INSTITUT <- toupper(df$INSTITUT)
# Convert mixed formats to YYYY-MM-DD
# Define the possible date formats
date_formats <- c(
"ymd HMS",  # YYYY-MM-DD HH:MM:SS
"mdy HM",   # MM/DD/YYYY HH:MM
"mdy"       # MM/DD/YYYY
)
# Use parse_date_time to handle multiple formats in a vectorized way
df$DATE_BIRTH <- parse_date_time(df$DATE_BIRTH, orders = date_formats)
df$DATE_DATA <- parse_date_time(df$DATE_DATA, orders = date_formats)
df$DATE_ADMIS <- parse_date_time(df$DATE_ADMIS, orders = date_formats)
df$SPEC_DATE <- parse_date_time(df$SPEC_DATE, orders = date_formats)
#convert date/time to character
df$DATE_BIRTH <- as.character(df$DATE_BIRTH)
df$DATE_DATA <- as.character(df$DATE_DATA)
df$DATE_ADMIS <- as.character(df$DATE_ADMIS)
df$SPEC_DATE <- as.character(df$SPEC_DATE)
View(df)
df$X_REFERRED <- ''
df[is.na(df)] <- ''
df[df == 'nan'] <- ''
df[df == 'NaN'] <- ''
df[df == 'NaT'] <- ''
df_clean <- df
cols_to_modify <- c(52:ncol(df))
abx_cleaned <- gsub("\\s+", "", cols_to_modify)
df_clean[] <- lapply(df_clean, function(x) gsub("\\s+", "", cols_to_modify))
View(df_clean)
df_clean <- df
View(df_clean)
df_cleaned <- df
cols_to_modify <- c(52:ncol(df))
# Define a regular expression that matches valid formats
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_cleaned <- df
df_cleaned[] <- lapply(df, function(cols_to_modify) {
cols_to_modify[valid_format(cols_to_modify)]  # Keep only values that match the valid format
})
View(df_cleaned)
cols_to_modify <- c(52:ncol(df))
# Define a regular expression that matches valid formats
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_cleaned <- df
df_cleaned[] <- lapply(df, function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
View(df_cleaned)
cols_to_modify <- c(52:ncol(df))
# Define a regular expression that matches valid formats
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_cleaned <- df
df_cleaned[cols_to_modify] <- lapply(df[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
View(df_cleaned)
View(df_cleaned)
df_cleaned[is.na(df_cleaned)] <- ''
View(df_cleaned)
writexl::write_xlsx(df_cleaned,  path =paste0("output/regular_data/",site_code,"_regular_data_cleaned.xlsx"))
standardize_format <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
x <- gsub("(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2", x)  # Add leading zero before decimal point if needed
# For numeric values (e.g., 0.25), remove unnecessary trailing zeros and add leading zero if missing
x <- gsub("^([><]=?)(\\.?\\d+)$", "\\10\\2", as.character(x))  # Add leading zero if it's a decimal number
# Remove unnecessary decimals (e.g., 64.0 -> 64)
x <- gsub("(\\d)\\.0$", "\\1", x)
return(x)
}
# Apply standardization function to all columns
df_cleaned[cols_to_modify] <- lapply(df[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(standardize_format(col), col, NA)
})
df_cleaned[is.na(df_cleaned)] <- ''
writexl::write_xlsx(df_cleaned,  path =paste0("output/regular_data/",site_code,"_regular_data_cleaned.xlsx"))
gc()
site_code <- 'BGH'
#load data
df <- read.csv(paste0("site_df/",site_code ,"_raw_df.csv"))
#change column names case to upper
names(df) <- toupper(names(df))
df$INSTITUT <- toupper(df$INSTITUT)
# Convert mixed formats to YYYY-MM-DD
# Define the possible date formats
date_formats <- c(
"ymd HMS",  # YYYY-MM-DD HH:MM:SS
"mdy HM",   # MM/DD/YYYY HH:MM
"mdy"       # MM/DD/YYYY
)
# Use parse_date_time to handle multiple formats in a vectorized way
df$DATE_BIRTH <- parse_date_time(df$DATE_BIRTH, orders = date_formats)
df$DATE_DATA <- parse_date_time(df$DATE_DATA, orders = date_formats)
df$DATE_ADMIS <- parse_date_time(df$DATE_ADMIS, orders = date_formats)
df$SPEC_DATE <- parse_date_time(df$SPEC_DATE, orders = date_formats)
#convert date/time to character
df$DATE_BIRTH <- as.character(df$DATE_BIRTH)
df$DATE_DATA <- as.character(df$DATE_DATA)
df$DATE_ADMIS <- as.character(df$DATE_ADMIS)
df$SPEC_DATE <- as.character(df$SPEC_DATE)
#set x_referred value to blank for regular data
df$X_REFERRED <- ''
#remove NAN values
df[is.na(df)] <- ''
df[df == 'nan'] <- ''
df[df == 'NaN'] <- ''
df[df == 'NaT'] <- ''
df_clean <- df
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_cleaned <- df
df_cleaned[cols_to_modify] <- lapply(df_cleaned[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
# Function to standardize the format
standardize_format <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
x <- gsub("(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2", x)  # Add leading zero before decimal point if needed
# For numeric values (e.g., 0.25), remove unnecessary trailing zeros and add leading zero if missing
x <- gsub("^([><]=?)(\\.?\\d+)$", "\\10\\2", as.character(x))  # Add leading zero if it's a decimal number
# Remove unnecessary decimals (e.g., 64.0 -> 64)
x <- gsub("(\\d)\\.0$", "\\1", x)
return(x)
}
# Apply standardization function to all columns
df_cleaned[cols_to_modify] <- lapply(df_cleaned[cols_to_modify], function(col) {
sapply(col, standardize_format)
})
gc()
site_code <- 'BGH'
#load data
df <- read.csv(paste0("site_df/",site_code ,"_raw_df.csv"))
#change column names case to upper
names(df) <- toupper(names(df))
df$INSTITUT <- toupper(df$INSTITUT)
# Convert mixed formats to YYYY-MM-DD
# Define the possible date formats
date_formats <- c(
"ymd HMS",  # YYYY-MM-DD HH:MM:SS
"mdy HM",   # MM/DD/YYYY HH:MM
"mdy"       # MM/DD/YYYY
)
# Use parse_date_time to handle multiple formats in a vectorized way
df$DATE_BIRTH <- parse_date_time(df$DATE_BIRTH, orders = date_formats)
df$DATE_DATA <- parse_date_time(df$DATE_DATA, orders = date_formats)
df$DATE_ADMIS <- parse_date_time(df$DATE_ADMIS, orders = date_formats)
df$SPEC_DATE <- parse_date_time(df$SPEC_DATE, orders = date_formats)
#convert date/time to character
df$DATE_BIRTH <- as.character(df$DATE_BIRTH)
df$DATE_DATA <- as.character(df$DATE_DATA)
df$DATE_ADMIS <- as.character(df$DATE_ADMIS)
df$SPEC_DATE <- as.character(df$SPEC_DATE)
#set x_referred value to blank for regular data
df$X_REFERRED <- ''
#remove NAN values
df[is.na(df)] <- ''
df[df == 'nan'] <- ''
df[df == 'NaN'] <- ''
df[df == 'NaT'] <- ''
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
# Function to standardize the format
standardize_format <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
x <- gsub("(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2", x)  # Add leading zero before decimal point if needed
# For numeric values (e.g., 0.25), remove unnecessary trailing zeros and add leading zero if missing
x <- gsub("^([><]=?)(\\.?\\d+)$", "\\10\\2", as.character(x))  # Add leading zero if it's a decimal number
# Remove unnecessary decimals (e.g., 64.0 -> 64)
x <- gsub("(\\d)\\.0$", "\\1", x)
return(x)
}
# Apply standardization function to all columns
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
sapply(col, standardize_format)
})
df_clean[is.na(df_clean)] <- ''
View(df_clean)
View(df)
library(stringr)
View(df_clean)
df_clean <- df
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
View(df_clean)
View(df_clean)
standardize_format_optimized <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
# Only prepend "0" before decimal point if it's missing (e.g., <.25 becomes <0.25)
x <- str_replace_all(x, "(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2")  # Add leading zero before decimal point if needed
# Remove unnecessary trailing zeros for numbers like 64.0 -> 64
x <- str_replace_all(x, "(\\d)\\.0$", "\\1")  # Remove trailing zero for whole numbers
# Ensure that the decimal point is retained only if needed (e.g., .25 becomes 0.25, 4.0 becomes 4)
x <- str_replace_all(x, "(^|\\s)(\\.?\\d+)$", "\\10\\2")  # Add leading zero for single digit decimals
return(x)
}
# Apply the function only to the selected columns based on indices
df_clean[cols_to_modify] <- df_clean[cols_to_modify] %>%
lapply(function(col) standardize_format_optimized(col))
View(df_clean)
standardize_format_optimized <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
x <- str_replace_all(x, "(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2")  # Add leading zero before decimal point if needed
# For numeric values (e.g., 0.25), remove unnecessary trailing zeros and add leading zero if missing
x <- str_replace_all(x, "^([><]=?)(\\.?\\d+)$", "\\10\\2")  # Add leading zero if it's a decimal number
# Remove unnecessary decimals (e.g., 64.0 -> 64)
x <- str_replace_all(x, "(\\d)\\.0$", "\\1")
return(x)
}
# Apply the function only to the selected columns based on indices
df_clean[cols_to_modify] <- df_clean[cols_to_modify] %>%
lapply(function(col) standardize_format_optimized(col))
View(df_clean)
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
# Function to standardize the format
# Optimized function to standardize the format using stringr
standardize_format_optimized <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
# Only prepend "0" before decimal point if it's missing (e.g., <.25 becomes <0.25)
x <- str_replace_all(x, "(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2")  # Add leading zero before decimal point if needed
# Remove unnecessary trailing zeros for numbers like 64.0 -> 64
x <- str_replace_all(x, "(\\d)\\.0$", "\\1")  # Remove trailing zero for whole numbers
# Ensure that the decimal point is retained only if needed (e.g., .25 becomes 0.25, 4.0 becomes 4)
x <- str_replace_all(x, "(^|\\s)(\\.?\\d+)$", "\\10\\2")  # Add leading zero for single digit decimals
return(x)
}
# Apply the function only to the selected columns based on indices
df_clean[cols_to_modify] <- df_cleaned[cols_to_modify] %>%
lapply(function(col) standardize_format_optimized(col))
#list of abx columns
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
# Function to standardize the format
# Optimized function to standardize the format using stringr
standardize_format_optimized <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
# Only prepend "0" before decimal point if it's missing (e.g., <.25 becomes <0.25)
x <- str_replace_all(x, "(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2")  # Add leading zero before decimal point if needed
# Remove unnecessary trailing zeros for numbers like 64.0 -> 64
x <- str_replace_all(x, "(\\d)\\.0$", "\\1")  # Remove trailing zero for whole numbers
# Ensure that the decimal point is retained only if needed (e.g., .25 becomes 0.25, 4.0 becomes 4)
x <- str_replace_all(x, "(^|\\s)(\\.?\\d+)$", "\\10\\2")  # Add leading zero for single digit decimals
return(x)
}
# Apply the function only to the selected columns based on indices
df_clean[cols_to_modify] <- df_clean[cols_to_modify] %>%
lapply(function(col) standardize_format_optimized(col))
df_clean[is.na(df_clean)] <- ''
View(df_clean)
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
# Function to standardize the format
# Optimized function to standardize the format using stringr
standardize_format_optimized <- function(x) {
# For comparison values (e.g., <5, >=128), standardize the number part
x <- str_replace_all(x, "(<|>=|>|<=|=)(\\.?\\d+)", "\\1\\0\\2")  # Add leading zero before decimal point if needed
# For numeric values (e.g., 0.25), remove unnecessary trailing zeros and add leading zero if missing
x <- str_replace_all(x, "^([><]=?)(\\.?\\d+)$", "\\10\\2")  # Add leading zero if it's a decimal number
# Remove unnecessary decimals (e.g., 64.0 -> 64)
x <- str_replace_all(x, "(\\d)\\.0$", "\\1")
return(x)
}
# Apply the function only to the selected columns based on indices
df_clean[cols_to_modify] <- df_clean[cols_to_modify] %>%
lapply(function(col) standardize_format_optimized(col))
df_clean[is.na(df_clean)] <- ''
View(df_clean)
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
# Function to remove invalid characters to abx columns
valid_format <- function(x) {
grepl("^([><]=?\\d*\\.?\\d+|\\d+\\.?\\d*)$", x)
}
# Apply the valid format check to each column and filter
df_clean[cols_to_modify] <- lapply(df_clean[cols_to_modify], function(col) {
# Use ifelse to replace values that do not match the format with NA
ifelse(valid_format(col), col, NA)
})
View(df_clean)
cols_to_modify <- c(52:ncol(df))
abx_cols <- names(df)[cols_to_modify]
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
abx_cols <- names(df)[cols_to_modify]
for (col in abx_cols) {
# Create a new column with the special characters (except period) for each selected column
df_clean[[paste(col, "SYM", sep = "_")]] <- sapply(str_extract_all(df_clean[[col]], "[^[:alnum:]\\s\\.]"),
function(x) paste(x, collapse = ""))
}
View(df_clean)
for (col in abx_cols) {
# Create a new column with the numeric value for each selected column
df_clean[[paste(col, "VALUE", sep = "_")]] <- sapply(str_extract_all(df_clean[[col]], "[0-9.]+"),
function(x) paste(x, collapse = ""))
}
View(df_clean)
df_clean <- df
#list of abx columns
cols_to_modify <- c(52:ncol(df))
abx_cols <- names(df)[cols_to_modify]
for (col in abx_cols) {
# Create a new column with the special characters (except period) for each selected column
df_clean[[paste(col, "SYM", sep = "_")]] <- sapply(str_extract_all(df_clean[[col]], "[^[:alnum:]\\s\\.]"),
function(x) paste(x, collapse = ""))
}
for (col in abx_cols) {
# Create a new column with the numeric value for each selected column
df_clean[[paste(col, "VALUE", sep = "_")]] <- sapply(str_extract_all(df_clean[[col]], "(?<=^|[^0-9.])[0-9]*\\.?[0-9]+(?=$|[^0-9.])"),
function(x) paste(x, collapse = ""))
}
writexl::write_xlsx(df_clean,  path =paste0("output/regular_data/",site_code,"_regular_data_cleaned.xlsx"))
df_clean <- df_clean %>%
mutate_at(vars(paste0(abx_cols,'_VALUE')), as.numeric)
writexl::write_xlsx(df_clean,  path =paste0("output/regular_data/",site_code,"_regular_data_cleaned.xlsx"))
